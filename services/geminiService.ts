import { Type } from "@google/genai";
import { AITextAnalysisResult, AnnotationType, FeedbackResult, AIImageAnalysisResult, SourceCredibility } from '../types';

const PROXY_URL = 'https://trusty-ldqx.onrender.com/api/gemini';

/**
 * A helper function to call the backend proxy which in turn calls the Gemini API.
 * @param endpoint The Gemini SDK method to call (e.g., 'generateContent').
 * @param params The parameters for the SDK method.
 * @returns The response from the Gemini API, as returned by the proxy.
 */
async function callGeminiProxy(endpoint: string, params: any): Promise<any> {
  try {
    const response = await fetch(PROXY_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ endpoint, params }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = `Proxy API call failed with status ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.message || errorJson.error || errorMessage;
      } catch (e) {
        console.error('Error parsing error response:', e);
        if (errorText) {
          errorMessage = `${errorMessage}: ${errorText}`;
        }
      }
      throw new Error(errorMessage);
    }

    return response.json();
  } catch (error) {
    console.error('Error calling Gemini proxy:', error);
    // Re-throw the error to be caught by the calling function's try/catch block
    throw error;
  }
}


const textAnalysisSchema = {
  type: Type.OBJECT,
  properties: {
    likelihood: { type: Type.NUMBER, description: "A score from 0 to 100 representing the likelihood the text is AI-generated." },
    summary: { type: Type.STRING, description: "A brief, one-paragraph summary of the analysis." },
    forAI: {
      type: Type.ARRAY,
      description: "Snippets and reasons supporting the conclusion that the text is AI-generated.",
      items: {
        type: Type.OBJECT,
        properties: {
          snippet: { type: Type.STRING },
          reason: { type: Type.STRING }
        }
      }
    },
    againstAI: {
      type: Type.ARRAY,
      description: "Snippets and reasons supporting the conclusion that the text is human-written.",
      items: {
        type: Type.OBJECT,
        properties: {
          snippet: { type: Type.STRING },
          reason: { type: Type.STRING }
        }
      }
    },
    wordCount: { type: Type.INTEGER },
    readability: { type: Type.STRING, description: "e.g., 'Easy to read', 'College level'" },
    complexWords: { type: Type.INTEGER }
  }
};

export const analyzeTextForAI = async (text: string): Promise<AITextAnalysisResult> => {
  const prompt = `Analyze the following text. Determine the likelihood it was generated by an AI. Provide specific snippets from the text as evidence for and against this conclusion. Also, provide a general analysis of its complexity and readability.

Text to analyze:
---
${text}
---

Your response MUST be in JSON format and adhere to the provided schema. Highlight specific phrases, not just single words.`;

  const params = {
    model: 'gemini-2.5-flash',
    contents: prompt,
    config: {
      responseMimeType: 'application/json',
      responseSchema: textAnalysisSchema,
      temperature: 0.2,
    }
  };
  
  const response = await callGeminiProxy('generateContent', params);
  const jsonResponse = JSON.parse(response.text);
  return jsonResponse as AITextAnalysisResult;
};

const feedbackSchema = {
    type: Type.OBJECT,
    properties: {
        summary: {
            type: Type.OBJECT,
            properties: {
                strengths: { type: Type.STRING, description: "A paragraph summarizing the strengths of the writing." },
                improvements: { type: Type.STRING, description: "A paragraph summarizing the main areas for improvement." }
            }
        },
        annotations: {
            type: Type.ARRAY,
            items: {
                type: Type.OBJECT,
                properties: {
                    snippet: { type: Type.STRING, description: "The exact text snippet being commented on." },
                    feedback: { type: Type.STRING, description: "Constructive feedback about the snippet." },
                    suggestion: { type: Type.STRING, description: "An optional, concrete suggestion for rewriting the snippet." },
                    type: { type: Type.STRING, enum: Object.values(AnnotationType), description: "The category of feedback." }
                }
            }
        }
    }
};

export const getFeedbackForText = async (text: string): Promise<FeedbackResult> => {
    const prompt = `Act as a helpful and encouraging writing coach. Analyze the following text for clarity, logic, evidence, and tone. Provide a summary of strengths and weaknesses. Then, provide specific, actionable annotations on snippets of the text. For each annotation, suggest a potential improvement if applicable. Identify any factual claims that might need verification.

Text to analyze:
---
${text}
---

Your response MUST be in JSON format and adhere to the provided schema. Ensure snippets are precise.`;
    
    const params = {
        model: 'gemini-2.5-flash',
        contents: prompt,
        config: {
            responseMimeType: 'application/json',
            responseSchema: feedbackSchema,
            temperature: 0.5,
        }
    };
    
    const response = await callGeminiProxy('generateContent', params);
    const jsonResponse = JSON.parse(response.text);
    return jsonResponse as FeedbackResult;
};


export const factCheckClaim = async (claim: string): Promise<{ summary: string, sources: any[] }> => {
  const params = {
    model: "gemini-2.5-flash",
    contents: `Fact-check the following claim and provide a summary of your findings. Use Google Search to find relevant sources. Claim: "${claim}"`,
    config: {
      tools: [{ googleSearch: {} }],
      temperature: 0.2,
    },
  };
    
    const response = await callGeminiProxy('generateContent', params);
    const summary = response.text;
    const sources = response.candidates?.[0]?.groundingMetadata?.groundingChunks ?? [];
    return { summary, sources };
};

const factCheckProcessorSchema = {
  type: Type.OBJECT,
  properties: {
    annotatedSummary: {
      type: Type.STRING,
      description: "A detailed summary of the fact-check findings, with citations like [1], [2] embedded in the text to reference the sources."
    },
    sourceDetails: {
      type: Type.ARRAY,
      description: "An array of sources with their credibility analysis.",
      items: {
        type: Type.OBJECT,
        properties: {
          url: { type: Type.STRING },
          title: { type: Type.STRING },
          credibility: { type: Type.STRING, enum: ['Very High', 'High', 'Medium High', 'Medium', 'Medium Low', 'Low', 'Very Low', 'Unknown'] },
          explanation: { type: Type.STRING, description: "A concise, one-sentence explanation for the credibility rating." }
        },
        required: ["url", "title", "credibility", "explanation"],
      }
    }
  }
};

export const processFactCheckResults = async (
  summary: string, 
  sources: { uri: string; title: string }[]
): Promise<{ annotatedSummary: string, sources: SourceCredibility[] }> => {
  const sourceList = sources
    .map((s, i) => `[${i + 1}] ${s.title || 'Untitled'}\nURL: ${s.uri}`)
    .join('\n\n');

  const prompt = `
    You are a helpful fact-checking assistant. You have been provided with an initial summary and a list of source URLs. Your task is to refine this into a final, user-friendly fact-check report.

    Follow these instructions carefully:
    1.  **Rewrite the Summary**: Read the initial summary and the list of sources. Write a comprehensive, clear summary of the findings. In your summary, you MUST embed citations in the format [1], [2], etc., to link statements to the source that backs them up.
    2.  **Analyze Source Credibility**: For each source provided, analyze its credibility based on its URL and title. Assign a credibility rating of 'Very High', 'High', 'Medium High', 'Medium', 'Medium Low', 'Low', or 'Very Low'. Provide a brief, one-sentence explanation for your rating. For example, a major news organization or scientific journal is 'High', while a personal blog is 'Low'. If you cannot determine, use 'Unknown'.
    3.  **Format Output**: Your entire response MUST be a single JSON object that strictly adheres to the provided schema.

    **Initial Summary:**
    ---
    ${summary}
    ---

    **Sources to Analyze:**
    ---
    ${sourceList}
    ---
  `;

  const params = {
    model: "gemini-2.5-flash",
    contents: prompt,
    config: {
      responseMimeType: 'application/json',
      responseSchema: factCheckProcessorSchema,
      temperature: 0.2,
    }
  };
  
  const response = await callGeminiProxy('generateContent', params);
  const jsonResponse = JSON.parse(response.text);
  
  return {
    annotatedSummary: jsonResponse.annotatedSummary,
    sources: jsonResponse.sourceDetails,
  };
};

export const analyzeImageForAI = async (base64Image: string, mimeType: string): Promise<AIImageAnalysisResult> => {
    const imagePart = { inlineData: { data: base64Image, mimeType } };
    
    const imageAnalysisSchema = {
        type: Type.OBJECT,
        properties: {
            isLikelyAI: { type: Type.BOOLEAN },
            likelihood: { type: Type.NUMBER, description: "A score from 0-100 of AI likelihood." },
            anomalies: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        reason: { type: Type.STRING },
                        box: {
                            type: Type.OBJECT,
                            properties: {
                                x: { type: Type.NUMBER },
                                y: { type: Type.NUMBER },
                                width: { type: Type.NUMBER },
                                height: { type: Type.NUMBER }
                            }
                        }
                    }
                }
            }
        }
    };

    const prompt = "Analyze this image for signs of AI generation. Look for common artifacts like strange hands, distorted text, unnatural textures, or logical inconsistencies. Provide a likelihood score and identify specific regions of anomalies with bounding boxes (normalized 0-1 values). Respond in JSON format according to the schema.";

    const params = {
        model: 'gemini-2.5-flash',
        contents: { parts: [imagePart, { text: prompt }] },
        config: {
            responseMimeType: 'application/json',
            responseSchema: imageAnalysisSchema
        }
    };
    
    const response = await callGeminiProxy('generateContent', params);
    return JSON.parse(response.text) as AIImageAnalysisResult;
};

export const generateAudioSummary = async (text: string): Promise<string> => {
  const prompt = `You are a helpful assistant. Summarize the following text into a short, spoken-word-style script of no more than 3 sentences. The summary should be friendly and easy to understand.

Text to summarize:
---
${text}
---

Spoken summary:`;

  const params = {
      model: 'gemini-2.5-flash',
      contents: prompt
  };
  
  const response = await callGeminiProxy('generateContent', params);
  return response.text;
};
